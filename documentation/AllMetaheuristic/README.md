# Evaluation Aspects for Optimization Methods

| **Aspect**                     | **Description**                                                                 | **Calculation Method**                                                                                          | **Higher Score Means**       |
|-------------------------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|-----------------------------|
| **Accuracy**                 | How close the solution is to the optimal value (lower fitness is better).      | `1 - (mean(fitness_scores) - min_fitness) / (max_fitness - min_fitness + 1e-10)`                             | Better (closer to optimal) |
| **Time Efficiency**          | How quickly the method completes the optimization (shorter runtime is better). | `1 - (mean(run_times) - min_time) / (max_time - min_time + 1e-10)`                                           | Better (faster)           |
| **Convergence Speed**        | How quickly the method reaches a near-optimal solution.                       | `1.0 if fitness < 0.5 else max(0, 1 - elapsed_time / 3.0)`, averaged over runs                               | Better (faster convergence) |
| **Scalability**              | How well the method scales with increased problem size (doubling dimension).  | `1 - (scalability_time - min_scalability) / (max_scalability - min_scalability + 1e-10)`                     | Better (scales well)      |
| **Memory Usage**             | Peak memory consumption during optimization (lower usage is better).          | `1 - (mean(memory_usages) - min_mem) / (max_mem - min_mem + 1e-10)`                                          | Better (lower memory use) |
| **Robustness to Noise**      | Performance when the objective function includes noise.                       | `1 - (mean(noisy_fitness_scores) - min_noisy_fitness) / (max_noisy_fitness - min_noisy_fitness + 1e-10)`    | Better (more robust)      |
| **Sensitivity to Parameters**| Sensitivity to hyperparameter changes (e.g., reduced population size).         | `1 - (mean(param_sensitivity_fitness) - min_param_fitness) / (max_param_fitness - min_param_fitness + 1e-10)`| Better (less sensitive)   |
| **Adaptability to Problem Complexity** | Ability to handle complex, multi-modal problems (Rastrigin function).         | `1 - (mean(rastrigin_fitness_scores) - min_rastrigin_fitness) / (max_rastrigin_fitness - min_rastrigin_fitness + 1e-10)` | Better (more adaptable)   |
| **Energy Efficiency**        | Estimated energy consumption (CPU usage Ã— runtime, lower is better).          | `1 - (mean(cpu_usages) - min_energy) / (max_energy - min_energy + 1e-10)`                                    | Better (lower energy use) |
| **Solution Stability Over Iterations** | Stability of the solution in later iterations (lower variance is better).     | `1 - stdev(short_run_fitnesses) / (mean(short_run_fitnesses) + 1e-10)`                                       | Better (more stable)      |
| **Exploration vs. Exploitation Balance** | Balance between exploring new solutions and exploiting known good ones.       | `1 - (final_fitness - min_fitness) / (initial_fitness - min_fitness + 1e-10)` if improvement, else 0.5       | Better (better balance)   |
| **Parallelization Efficiency** | Benefit from parallelization (e.g., doubled population size).                 | `max(1 - (mean(parallel_fitness) - min_parallel_fit) / (max_parallel_fit - min_parallel_fit + 1e-10), 1 - (mean(parallel_run_times) - min_parallel_time) / (max_parallel_time - min_parallel_time + 1e-10))` | Better (better scaling)   |
